<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>WebRTC IP PoC</title>
    <style>
        body {
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
            padding: 20px;
        }

        pre {
            background: #f4f4f6;
            padding: 10px;
            border-radius: 6px;
        }

        .ok {
            color: green;
        }

        .warn {
            color: #b06;
        }
    </style>
</head>

<body>
    <h1>WebRTC IP PoC</h1>
    <p>This page attempts to discover IP addresses (local & public) using a STUN server.</p>
    <button id="detect">Detect IPs</button>
    <div id="out"></div>

    <script>
        const out = document.getElementById('out');
        const seen = new Set();

        function log(text, cls) {
            const el = document.createElement('div');
            if (cls) el.className = cls;
            el.textContent = text;
            out.appendChild(el);
        }

        function extractIPs(candidateStr) {
            // matches IPv4 and IPv6 (simple)
            const ips = [];
            // IPv4
            const ipv4 = candidateStr.match(/([0-9]{1,3}(?:\.[0-9]{1,3}){3})/g);
            if (ipv4) ips.push(...ipv4);
            // IPv6 (very simple pattern)
            const ipv6 = candidateStr.match(/([0-9a-fA-F:]{2,})/g);
            if (ipv6) {
                // filter out false positives like 'UDP' or other tokens by the presence of ':'
                ips.push(...ipv6.filter(s => s.includes(':')));
            }
            return ips;
        }

        async function discoverIPs() {
            out.innerHTML = '';
            log('Starting discovery — creating RTCPeerConnection and offer...');

            const pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            // optional: create a data channel so ICE gathering starts quickly
            pc.createDataChannel('p');

            pc.onicecandidate = (ev) => {
                if (!ev.candidate) {
                    log('ICE gathering finished.', 'ok');
                    pc.close();
                    return;
                }
                const c = ev.candidate.candidate || '';
                const ips = extractIPs(c);
                ips.forEach(ip => {
                    if (!seen.has(ip)) {
                        seen.add(ip);
                        // heuristic: server-reflexive candidates usually contain "srflx"
                        const type = c.includes('srflx') ? 'public (srflx)' : (c.includes('host') ? 'host/local' : 'other');
                        log(`${ip}  —  candidate type: ${type}`);
                        console.log('ICE candidate:', c);
                    }
                });
            };

            try {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                // if the browser requires trickle ICE disabled, it may still call onicecandidate for final null candidate later
            } catch (err) {
                log('Error creating offer: ' + String(err), 'warn');
                console.error(err);
                pc.close();
            }
        }

        document.getElementById('detect').addEventListener('click', discoverIPs);
    </script>
</body>

</html>